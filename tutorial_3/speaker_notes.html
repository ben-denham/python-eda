<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Python EDA - Tutorial 3: Grouping and Presenting</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">.speaker-notes {
border: 2px solid black;
display: inline-block;
padding: 0 1em;
margin-right: auto;
}
.practice-input {
display: none;
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Python EDA - Tutorial 3: Grouping and Presenting</h1>
</header>
<h1 id="tutorial-3-grouping-and-presenting">Tutorial 3: Grouping and
Presenting</h1>
<p>In this tutorial you will:</p>
<ul>
<li>Visualise relationships between groups with Plotly</li>
<li>Grouping and aggregating data with Pandas to compare subsets of your
data</li>
<li>Export the results of your analysis to share with others</li>
</ul>
<div class="speaker-notes">
<p>Don’t forget to run this first cell to import Pandas and Plotly, and
to load our DataFrame of listings in this notebook.</p>
</div>
<pre class="code"><code>%pip install pandas plotly nbformat

import pandas as pd
import plotly.express as px
# Ensure plots will be exported correctly by nbconvert
# (only needed in Colab, should be disabled in local Jupyter)
import plotly.io as pio
pio.renderers.default = &#39;notebook&#39;

listings_df = pd.read_csv(&#39;https://ben-denham.github.io/python-eda/data/inside_airbnb_listings_nz_2023_09.csv&#39;)

listings_df</code></pre>
<h2 id="plotting-groups">Plotting groups</h2>
<div class="speaker-notes">
<p>When exploring a dataset, we often want to compare different groups
or subsets of the data.</p>
<p>Plotly makes a lot of group comparisons easy if we have a
<em>tidy</em> DataFrame - with a <strong>row for each data
point</strong> and a <strong>column for each attribute</strong> -
including <em>categorical</em> attributes we want to group by.</p>
<p>For example, we can specify a column to colour data points by.</p>
<p><strong>Note:</strong> We can hide/show groups using the legend.</p>
</div>
<p>Colour each listing by its room type:</p>
<div class="practice-input">
<pre class="code"><code>px.scatter_mapbox(
    listings_df,
    lon=&#39;longitude&#39;,
    lat=&#39;latitude&#39;,
    zoom=3,
    height=500,
).update_layout(
    mapbox_style=&#39;open-street-map&#39;,
)</code></pre>
</div>
<div class="practice-output">
<pre class="code"><code>px.scatter_mapbox(
    listings_df,
    lon=&#39;longitude&#39;,
    lat=&#39;latitude&#39;,
    zoom=3,
    height=500,
    color=&#39;room_type&#39;,
).update_layout(
    mapbox_style=&#39;open-street-map&#39;,
)</code></pre>
</div>
<div class="speaker-notes">
<p>We can take this one step further and create a separate subplot for
the data points belonging to each group by specifying a categorical
column as a <code>facet_row</code> or <code>facet_col</code>.</p>
<p>In the plot below, note that we:</p>
<ul>
<li>Sort the data by the <code>accommodates</code> column, so that the
facet plots are ordered by that value.</li>
<li>Increase the height of the output to better view the large number of
plots.</li>
<li>Set <code>histnorm=&#39;percent&#39;</code> so that groups with few data
points still have a “full size” plot.</li>
</ul>
</div>
<p>Plot the distribution of listing prices, with a separate subplot for
each number of people that a listing can accommodate:</p>
<pre class="code"><code>px.histogram(
    listings_df[listings_df[&#39;price_nzd&#39;] &lt; 500].sort_values(by=&#39;accommodates&#39;),
    x=&#39;price_nzd&#39;,
    facet_row=&#39;accommodates&#39;,
    height=2000,
    histnorm=&#39;percent&#39;,
)</code></pre>
<div class="speaker-notes">
<p>While not about strictly about groups, a <code>scatter_matrix</code>
is a very convenient shorthand to generate subplots for each combination
of numeric columns on the x and y axis:</p>
<ul>
<li>We limit the price data to focus on a more interesting subset.</li>
<li>Some trends emerge, like the price floor for different values of
<code>accommodates</code>.</li>
</ul>
</div>
<p>Plot a scatter matrix of numeric columns:</p>
<pre class="code"><code>px.scatter_matrix(
    listings_df[listings_df[&#39;price_nzd&#39;] &lt; 500],
    dimensions=[
        &#39;price_nzd&#39;,
        &#39;accommodates&#39;,
        &#39;review_scores_rating&#39;,
        &#39;number_of_reviews&#39;,
    ],
    color=&#39;room_type&#39;,
    height=900,
    width=900,
)</code></pre>
<h3 id="plotting-groups-based-on-numeric-columns">Plotting groups based
on numeric columns</h3>
<div class="speaker-notes">
<p>Not only can we colour points by categorical columns like
<code>room_type</code>, but we can also use numeric columns:</p>
</div>
<p>Colour each listing by its price (ignoring outliers):</p>
<div class="practice-input">
<pre class="code"><code>px.scatter_mapbox(
    listings_df[listings_df[&#39;price_nzd&#39;] &lt;= 500],
    lon=&#39;longitude&#39;,
    lat=&#39;latitude&#39;,
    zoom=3,
    height=500,
).update_layout(
    mapbox_style=&#39;open-street-map&#39;,
)</code></pre>
</div>
<div class="practice-output">
<pre class="code"><code>px.scatter_mapbox(
    listings_df[listings_df[&#39;price_nzd&#39;] &lt;= 500],
    lon=&#39;longitude&#39;,
    lat=&#39;latitude&#39;,
    zoom=3,
    height=500,
    color=&#39;price_nzd&#39;,
).update_layout(
    mapbox_style=&#39;open-street-map&#39;,
)</code></pre>
</div>
<div class="speaker-notes">
<p>Sometimes we’d like to treat a numeric column like a categorical
column in our visualisation.</p>
<p>We can do this by using <code>pd.qcut()</code> to create a
categorical column by dividing a numeric column into <em>bins</em>.</p>
<ul>
<li>Using <code>pd.qcut()</code> makes each bin <strong>has the same
number of data points</strong>, while <code>pd.cut()</code> makes each
bin <strong>cover an equal-length interval of the numeric
column</strong>.</li>
<li>We need to convert each “bin” value to a string in order to display
it with Plotly.</li>
</ul>
</div>
<p>Plot the distribution of review counts for different tiers of
pricing:</p>
<div class="practice-input">
<pre class="code"><code>listings_df[&#39;price_bin&#39;] =

px.box(
    # Ensure lower price bins are shown first.
    listings_df.sort_values(by=&#39;price_nzd&#39;),
    x=&#39;price_bin&#39;,
    y=&#39;number_of_reviews&#39;,
)</code></pre>
</div>
<div class="practice-output">
<pre class="code"><code>listings_df[&#39;price_bin&#39;] = pd.qcut(listings_df[&#39;price_nzd&#39;], q=10).astype(str)

px.box(
    # Ensure lower price bins are shown first.
    listings_df.sort_values(by=&#39;price_nzd&#39;),
    x=&#39;price_bin&#39;,
    y=&#39;number_of_reviews&#39;,
)</code></pre>
</div>
<h2 id="grouping-and-aggregating-data-with-pandas">Grouping and
aggregating data with Pandas</h2>
<div class="speaker-notes">
<p>We can use Pandas’ <code>groupby()</code> to split up a DataFrame
according to a categorical attribute.</p>
<p>If you’re familiar with SQL, you’ll see similarities to the
<code>GROUP BY</code> clause.</p>
<ul>
<li>We can loop over the “groups”, getting the attribute value and a
DataFrame of rows having that attribute value</li>
<li><code>.shape</code> returns the number of rows and number of columns
as a pair (tuple)</li>
</ul>
</div>
<p>Print the number of listings for each type of room:</p>
<div class="practice-input">
<pre class="code"><code>room_type_groups =

for room_type, room_type_group_df in room_type_groups:
    print(&#39;Room type:&#39;, room_type)
    print(room_type_group_df.shape[0])</code></pre>
</div>
<div class="practice-output">
<pre class="code"><code>room_type_groups = listings_df.groupby(&#39;room_type&#39;)

for room_type, room_type_group_df in room_type_groups:
    print(&#39;Room type:&#39;, room_type)
    print(room_type_group_df.shape[0])</code></pre>
</div>
<div class="speaker-notes">
<p><code>groupby()</code> can also be used to produce a DataFrame of
aggregate statistics for each group. In the following, see how we:</p>
<ul>
<li>Specify the columns from which to create a group for each
combinations of values (<code>[&#39;accommodates&#39;, &#39;room_type&#39;]</code>)</li>
<li>Use indexing to select a list of columns to calculate the statistic
for (<code>[&#39;price_nzd&#39;, &#39;review_scores_rating&#39;]</code>)</li>
<li>Choose one or more statistics to calculate:
<code>agg([&#39;mean&#39;, &#39;std&#39;])</code></li>
</ul>
</div>
<pre class="code"><code>indexed_stats_df = (
    listings_df
    .groupby([&#39;accommodates&#39;, &#39;room_type&#39;])
    [[&#39;price_nzd&#39;, &#39;review_scores_rating&#39;]]
    .agg([&#39;mean&#39;, &#39;std&#39;])
)

indexed_stats_df</code></pre>
<ul>
<li>Calling <code>.agg()</code> with a list of statistics also converts
the columns into a <em>multi-level index</em>
<ul>
<li>We can flatten them with a list comprehension</li>
<li>This issue does not occur when passing a single statistic name to
<code>.agg()</code> instead of a list, or when performing aggregation
against a single numeric column instead of a list.</li>
</ul></li>
<li><code>.groupby()</code> converts the group columns into an
<em>index</em>
<ul>
<li>We can convert them back into regular columns with
<code>.reset_index()</code></li>
</ul></li>
</ul>
<pre class="code"><code>stats_df = indexed_stats_df.copy()
stats_df.columns = [&#39;_&#39;.join(col) for col in stats_df.columns]
stats_df = stats_df.reset_index()

stats_df</code></pre>
<div class="speaker-notes">
<p><code>.groupby()</code> is a very powerful tool for reshaping data
into the right <em>tidy</em> format that will support the plot you
want.</p>
</div>
<p>Such DataFrames produced with <code>groupby()</code> can be very
useful for producing plots of statistics, like bar charts:</p>
<pre class="code"><code>px.bar(
    stats_df.sort_values(by=&#39;accommodates&#39;),
    x=&#39;accommodates&#39;,
    y=&#39;price_nzd_mean&#39;,
    color=&#39;room_type&#39;,
    barmode=&#39;group&#39;,
    title=&#39;Mean Price&#39;,
)</code></pre>
<h2 id="sharing-results-with-others">Sharing results with others</h2>
<div class="speaker-notes">
<p>We can easily generate a CSV of our cleaned up and aggregated
DataFrame:</p>
</div>
<p>Export our group statistics to a CSV file:</p>
<pre class="code"><code>stats_df.to_csv(&#39;stats_df.csv&#39;, index=False)</code></pre>
<p>Open the file browser from the left sidebar, right-click on the
<code>stats_df.csv</code>, and click <code>Download</code>.</p>
<h3 id="sharing-the-notebook">Sharing the notebook</h3>
<div class="speaker-notes">
<p>We can also export our Jupyter notebook as a shareable HTML file.</p>
<ul>
<li>HTML is the <strong>format used by web pages</strong>, so we can
<strong>open the file in a web browser</strong>.</li>
<li>The key benefit of exporting as HTML is that the <strong>plots will
remain interactive</strong>.</li>
<li>Be careful of previews in SharePoint etc. that disable
JavaScript.</li>
</ul>
</div>
<p>To export this notebook as an HTML file:</p>
<ol type="1">
<li>Select <code>File -&gt; Download -&gt; Download .ipynb</code></li>
<li>Open the file browser from the left sidebar, and upload the file you
downloaded.</li>
<li>Run the following cell to execute the shell command to convert the
uploaded <code>.ipynb</code> file to a <code>.html</code> file:</li>
<li>Right-click on the generated <code>python_eda_tutorial_3.html</code>
file in the file browser and click <code>Download</code>.</li>
<li>Open the downloaded file in any web browser.</li>
</ol>
<pre class="code"><code>!jupyter nbconvert --to html python_eda_tutorial_3.ipynb</code></pre>
<div class="speaker-notes">
<p>Jupyter notebooks are a convenient tool for making repeatable
reports.</p>
<ol type="1">
<li>When you have new data, just re-run the notebook with new input
files.</li>
<li>Use Text cells to tell a story about the data - use Markdown for
text formatting.</li>
<li>Advanced users can see exactly what code ran to produce the plot -
allowing them to scrutinise your assumptions in interpreting and
cleaning the data.</li>
</ol>
</div>
<section id="markdown-demo" class="cell markdown">
<h4>Markdown Demo</h4>
<p>Text/Markdown cells let us provide <strong>explanations</strong> for
our analyses with <em>rich-text</em> formatting.</p>
<ul>
<li>This</li>
<li>is</li>
<li>a bullet list</li>
</ul>
<ol type="1">
<li>This</li>
<li>is</li>
<li>a numbered list</li>
</ol>
<pre><code>{
    &quot;format&quot;: &quot;JSON&quot;,
    &quot;title&quot;: &quot;Code block demonstration&quot;
}</code></pre>
<p><span class="math display"><em>a</em><sup>2</sup> + <em>b</em><sup>2</sup> = <em>c</em><sup>2</sup></span></p>
<p>A <a href="https://www.markdownguide.org/cheat-sheet/">link</a> to a
Markdown guide.</p>
</section>
<h1 id="practice-exercises">Practice Exercises</h1>
<h2 id="bringing-it-all-together">1. Bringing it all together</h2>
<p>Use everything you’ve learned to answer a critical question for our
analysis: <strong>Do more expensive listings typically have higher
ratings?</strong></p>
<p>There are different ways you could approach this analysis, but
consider the following points:</p>
<ol type="1">
<li>How do you want to judge how “expensive” a listing is? E.g. Should
it be based on price, or price-per-person?</li>
<li>Given what we learned about ratings in the previous tutorial, do you
want to exclude listings with few reviews?</li>
<li>Visualising the relationship between expensiveness and rating will
be important, but what kind of visualisation will be easiest to
interpret? Perhaps a scatter plot? Or maybe convert one of the columns
into a categorical column with <code>pd.cut()</code> or
<code>pd.qcut()</code> and then use a box plot? Or
<code>groupby()</code> the categorical column to produce a table of
summary statistics per group?</li>
<li>Add a Text/Markdown cell to explain what you can observe from your
visualisation(s).</li>
</ol>
<pre class="code"><code></code></pre>
<details>
<summary>
Hint: code for calculating price-per-person
</summary>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>] <span class="op">=</span> listings_df[<span class="st">&#39;price_nzd&#39;</span>] <span class="op">/</span> listings_df[<span class="st">&#39;accommodates&#39;</span>]</span></code></pre></div>
</details>
<div class="speaker-notes">
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>] <span class="op">=</span> listings_df[<span class="st">&#39;price_nzd&#39;</span>] <span class="op">/</span> listings_df[<span class="st">&#39;accommodates&#39;</span>]</span></code></pre></div>
</div>
<details>
<summary>
Hint: code for creating a categorical column from a numeric column
</summary>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>], q<span class="op">=</span><span class="dv">10</span>).astype(<span class="bu">str</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># If you bin the rating instead, you may need to drop duplicate bins.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;rating_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;review_scores_rating&#39;</span>], q<span class="op">=</span><span class="dv">10</span>, duplicates<span class="op">=</span><span class="st">&#39;drop&#39;</span>).astype(<span class="bu">str</span>)</span></code></pre></div>
</details>
<div class="speaker-notes">
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>], q<span class="op">=</span><span class="dv">10</span>).astype(<span class="bu">str</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"># If you bin the rating instead, you may need to drop duplicate bins.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;rating_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;review_scores_rating&#39;</span>], q<span class="op">=</span><span class="dv">10</span>, duplicates<span class="op">=</span><span class="st">&#39;drop&#39;</span>).astype(<span class="bu">str</span>)</span></code></pre></div>
</div>
<details>
<summary>
Hint: code for excluding listings with few reviews
</summary>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>reviewed_listings_df <span class="op">=</span> listings_df[listings_df[<span class="st">&#39;number_of_reviews&#39;</span>] <span class="op">&gt;</span> <span class="dv">100</span>]</span></code></pre></div>
</details>
<div class="speaker-notes">
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>reviewed_listings_df <span class="op">=</span> listings_df[listings_df[<span class="st">&#39;number_of_reviews&#39;</span>] <span class="op">&gt;</span> <span class="dv">100</span>]</span></code></pre></div>
</div>
<details>
<summary>
Full example answer
</summary>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>] <span class="op">=</span> listings_df[<span class="st">&#39;price_nzd&#39;</span>] <span class="op">/</span> listings_df[<span class="st">&#39;accommodates&#39;</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>], q<span class="op">=</span><span class="dv">10</span>).astype(<span class="bu">str</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>reviewed_listings_df <span class="op">=</span> listings_df[listings_df[<span class="st">&#39;number_of_reviews&#39;</span>] <span class="op">&gt;</span> <span class="dv">100</span>]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>px.box(</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure lower price bins are shown first.</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    reviewed_listings_df.sort_values(by<span class="op">=</span><span class="st">&#39;price_nzd_per_person&#39;</span>),</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">&#39;price_nzd_per_person_bin&#39;</span>,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">&#39;review_scores_rating&#39;</span>,</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</details>
<div class="speaker-notes">
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>] <span class="op">=</span> listings_df[<span class="st">&#39;price_nzd&#39;</span>] <span class="op">/</span> listings_df[<span class="st">&#39;accommodates&#39;</span>]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>listings_df[<span class="st">&#39;price_nzd_per_person_bin&#39;</span>] <span class="op">=</span> pd.qcut(listings_df[<span class="st">&#39;price_nzd_per_person&#39;</span>], q<span class="op">=</span><span class="dv">10</span>).astype(<span class="bu">str</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>reviewed_listings_df <span class="op">=</span> listings_df[listings_df[<span class="st">&#39;number_of_reviews&#39;</span>] <span class="op">&gt;</span> <span class="dv">100</span>]</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>px.box(</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure lower price bins are shown first.</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    reviewed_listings_df.sort_values(by<span class="op">=</span><span class="st">&#39;price_nzd_per_person&#39;</span>),</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">&#39;price_nzd_per_person_bin&#39;</span>,</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">&#39;review_scores_rating&#39;</span>,</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<h2 id="extra-for-experts---aggregation-practice">2. Extra for Experts -
Aggregation Practice</h2>
<p>In the exercises below, be wary of indexes, column names, multi-index
columns in the DataFrames produced by <code>.groupby()</code>.</p>
<h3 id="a.-which-parent-region-has-the-highest-average-listing-price">2a.
Which parent region has the highest average listing price?</h3>
<p>Extra: Does the answer change depending on whether you use a mean or
median for the average? what does that indicate?</p>
<div class="hint">
<p>Hint: Use a <code>groupby()</code> and <code>agg()</code> with an
appropriate average statistic like <code>&#39;mean&#39;</code> or
<code>&#39;median&#39;</code>. Then sort the result by
<code>price_nzd</code>.</p>
</div>
<div class="practice">
<pre class="code"><code>region_price_stats_df = (
    listings_df
    .groupby(&#39;region_parent_name&#39;)
    [[&#39;price_nzd&#39;]]
    .agg([&#39;median&#39;, &#39;mean&#39;])
)
region_price_stats_df.columns = [&#39;_&#39;.join(col) for col in region_price_stats_df.columns]
region_price_stats_df.sort_values(by=&#39;price_nzd_median&#39;)</code></pre>
</div>
<h3 id="b.-do-home-listings-cost-more-are-they-better-reviewed-do-they-accommodate-more-people">2b.
Do “home” listings cost more? Are they better reviewed? Do they
accommodate more people?</h3>
<p>Any listing with “home” in it’s name should be considered a “home”
listing.</p>
<div class="hint">
<p>Use <code>.str.lower()</code> and <code>.str.contains()</code> on the
<code>name</code> column to create a Boolean column that indicates which
listings have names with the keyword “home”, then use appropriate
<code>groupby()</code>s and/or plots.</p>
</div>
<div class="practice">
<pre class="code"><code>listings_df[&#39;is_home&#39;] = listings_df[&#39;name&#39;].str.lower().str.contains(&#39;home&#39;)
(
    listings_df
    .groupby(&#39;is_home&#39;)
    [[&#39;price_nzd&#39;, &#39;review_scores_rating&#39;, &#39;accommodates&#39;]]
    .agg([&#39;mean&#39;, &#39;median&#39;])
)</code></pre>
</div>
<h3 id="c.-of-hosts-with-at-least-10-reviewed-listings-who-has-the-highest-average-rating">2c.
Of hosts with at least 10 reviewed listings, who has the highest average
rating?</h3>
<div class="hint">
<p>Use a <code>groupby(&#39;host_name&#39;)</code> on
<code>review_scores_rating</code> with
<code>.agg([&#39;count&#39;, &#39;mean&#39;])</code> to get both the count and mean of
the ratings. Then filter hosts based on the count of listings.</p>
</div>
<div class="practice">
<pre class="code"><code>host_stats_df = (
    listings_df
    .groupby(&#39;host_name&#39;)
    [&#39;review_scores_rating&#39;]
    .agg([&#39;count&#39;, &#39;mean&#39;])
)
(
    host_stats_df
    [host_stats_df[&#39;count&#39;] &gt;= 10]
    .sort_values(by=&#39;mean&#39;)
)</code></pre>
</div>
<h3 id="d.-use-a-bar-chart-to-show-how-many-listings-of-each-room-type-there-are-in-each-parent-region.">2d.
Use a bar chart to show how many listings of each room type there are in
each parent region.</h3>
<div class="hint">
<p>Use a <code>groupby()</code> and <code>agg()</code> with the
<code>&#39;size&#39;</code> statistic (which counts the number of rows in the
group, as opposed to <code>&#39;count&#39;</code> which counts the number of
non-<code>NaN</code> values in a column).</p>
</div>
<div class="practice">
<pre class="code"><code>region_room_counts_df = (
    listings_df
    .groupby([&#39;region_parent_name&#39;, &#39;room_type&#39;])
    .agg(&#39;size&#39;)
    .reset_index()
)
px.bar(
    region_room_counts_df.sort_values(by=0, ascending=False),
    x=&#39;region_parent_name&#39;,
    y=0,
    color=&#39;room_type&#39;,
    barmode=&#39;group&#39;,
)</code></pre>
</div>
</body>
</html>
